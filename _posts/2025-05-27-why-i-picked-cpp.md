---
layout: post
title: "Why I Picked C++ for Fun and Not Pain (Mostly)"
date: 2025-05-27
---


When I first got into programming, I just wanted to make video games. That was the dream. So I jumped into C++ — not because it was easy (it’s not), but because I thought, "Real programmers use C++ (or C)".

At first, I was hopping between game engines and frameworks, trying out “the best” tools in the market without really settling on one. I wrote a few small games, messed around with SDL, Unreal Engine, and even a few OpenGL experiments. Eventually, C++ started making sense — that is, until I met Modern C++. That part still doesn’t make any sense.

Am I a professional C++ developer? Not even close. But I like building things — especially games and graphics-related stuff. And since I already had a bit of C++ muscle, sticking with it felt easier than starting over with Python or JavaScript.

## Some Things I’ve Built in C++:
- A Snake game
- A Sudoku solver
- A CHIP-8 emulator
- A maze generator with pathfinding
- A 2D solar system simulator
- A raytracing experiment
- Some Unreal Engine code
- A half-baked OpenGL abstraction layer

## What I’ve Learned From Writing C++
(Not a lot, but here’s my 2 cents)

C++ teaches you to slow down and think. Sometimes painfully. But when things click, like figuring out pointers or getting your render loop to run without exploding, it feels great, like my own **eureka** moment. It forces you to understand what’s going on under the hood, and I like that.

It also made me more confident tackling topics like memory, graphics pipelines, and system-level design. That doesn’t mean I always get it right, but at least now I know why things are going wrong.

## What’s Next?
I want to build actual games that people can play. For that, I’m moving to Godot (because finishing games is more important than writing a perfect engine from scratch). But I’ll keep using C++ for all the other fun stuff — raytracers, emulators, simulators, maybe even a physics sandbox.

Oh, and I want to explore Golang too. It looks like a solid language for backend networking — clean syntax, good performance, and jobs out there too. It feels like a good fit for building multiplayer infrastructure for future projects.